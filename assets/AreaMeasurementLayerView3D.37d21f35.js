var e=Object.defineProperty,t=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,r=(t,i,s)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s,n=(e,n)=>{for(var o in n||(n={}))i.call(n,o)&&r(e,o,n[o]);if(t)for(var o of t(n))s.call(n,o)&&r(e,o,n[o]);return e};import{aO as o,X as a,cn as h,lZ as l,km as c,fD as d,fF as p,cq as u,kk as g,l_ as m,fd as f,lj as _,lk as y,jr as v,gY as V,fN as x,l$ as w,lb as L,lc as b,c2 as P,kl as C,m0 as S,m1 as E,m2 as D,ko as M,bZ as G,fE as z,m3 as T,gI as R,m4 as A,aX as O,eF as I,gv as k,b1 as j,la as q,F as U,G as F,H as W,bq as Z,br as B,eO as N,ld as H,le as X,m5 as Y,aL as $,m6 as Q,m7 as J,cB as K,cs as ee,lP as te,m8 as ie,m9 as se,ma as re,k3 as ne,kf as oe,cJ as ae,B as he,ab as le,aP as ce,h8 as de,M as pe,a1 as ue,f6 as ge,dQ as me,mb as fe,mc as _e,md as ye,me as ve,mf as Ve,mg as xe,lM as we,dS as Le,mh as be,mi as Pe,mj as Ce,mk as Se,ml as Ee,mm as De,mn as Me,ff as Ge,js as ze,bt as Te,iA as Re,iC as Ae,iE as Oe,iF as Ie,iH as ke,iI as je,mo as qe,iK as Ue,iL as Fe,iM as We,iN as Ze,iO as Be,iP as Ne,iQ as He,iS as Xe,iT as Ye,iV as $e,iW as Qe,iX as Je,iY as Ke,j1 as et,ik as tt,im as it,io as st,ip as rt,li as nt,ir as ot,lV as at,jT as ht,ij as lt,gE as ct,lq as dt,l9 as pt,ls as ut,lu as gt,gZ as mt,lp as ft,gC as _t,mp as yt,mq as vt,lt as Vt,mr as xt,lv as wt,ll as Lt,ig as bt,ih as Pt}from"./vendor.7103ff48.js";import{R as Ct,e as St,i as Et,t as Dt,v as Mt,j as Gt,f as zt,l as Tt,_ as Rt,d as At}from"./viewUtils.819cf53c.js";import{geodesicArea as Ot}from"./geometryEngine.2f06c96c.js";import{c as It,m as kt}from"./LineVisualElement.a7c721d3.js";function jt(e,t,i){const s={distance:null};return Ct(s,[e[0],e[1]],[t[0],t[1]],i),s.distance}function qt(e,t,i){const s=t[0]-e[0],r=t[1]-e[1],n=i[0]-e[0],o=i[1]-e[1];return.5*Math.abs(s*o-r*n)}function Ut(e,t,i,s){const r=Bt;return l(e,s,Ft)&&l(t,s,Wt)&&l(i,s,Zt)?(r.setPoint(0,0,Ft),r.setPoint(0,1,Wt),r.setPoint(0,2,Zt),Math.abs(Ot(r,"square-meters"))):0}const Ft=h(),Wt=h(),Zt=h(),Bt=new o({rings:[[Ft,Wt,Zt]],spatialReference:a.WGS84}),Nt=h();class Ht{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=h(),this.areaCentroidRenderCoords=h(),this.geodesicAreaCentroidRenderCoords=h(),this._length=0,this._centroidRenderCoords=h(),this._planeWorldCoords=v(),this._worldUp=h(),this._worldTangent=h(),this._frame=[h(),h(),h()],this._pathVersion=-1,this._validMeasurement=!1,this._tempU=h(),this._tempV=h(),this._tempVec3=h(),this._tempSphere={center:h(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,t,i,s,r){const n=this.unitNormalizer,o=this._sceneView.renderSpatialReference,a=this.unitNormalizer.spatialReference;if(this._pathVersion===e.version&&this._validMeasurement===i&&!r)return!1;this._pathVersion=e.version,this._validMeasurement=i;const h=e.numVertices;this._resize(h);const l=V(t.spatialReference),c=x(t.spatialReference,l)&&w(t.spatialReference),d=this.positionsGeographic,p=this.positionsWorldCoords,u=this.positionsRenderCoords,g=this.positionsSpherical;e.forEachVertexPosition(((e,i)=>{(function(e,t){t.hasZ||(t.z=j(q(e,t,"ground"),0))})(t.elevationProvider,e),L(e,p[i],a),L(e,u[i],o),c&&(b(e,d[i]),L(e,g[i],l),_(g[i],g[i]))}));const m=this._updatePathLengths(i);if(this.pathLength=this._length>1?new St(n.normalizeDistance(m),"meters"):null,c){const e=this._updateGeodesicPathLengths(i,a);this.geodesicPathLength=this._length>1?new St(e,"meters"):null}else this.geodesicPathLength=null;return i?(this._updateArea(t,n,o,a,s),c&&this._updateGeodesicArea(t),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(h()),this.positionsRenderCoords.push(h()),this.positionsProjectedWorldCoords.push(P()),this.positionsFittedRenderCoords.push(h()),this.positionsGeographic.push(h()),this.positionsSpherical.push(h()),this.positionsStereographic.push(P()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,i=this.pathSegmentLengths;let s=0;for(let r=0;r<this._length;++r){const n=i[r]=C(t[r],t[(r+1)%this._length]);(r<this._length-1||e)&&(s+=n)}return s}_updateGeodesicPathLengths(e,t){const i=this.positionsGeographic,s=this.geodesicPathSegmentLengths;let r=0;for(let n=0;n<this._length;++n){const o=s[n]=jt(i[n],i[(n+1)%this._length],t);(n<this._length-1||e)&&(r+=o)}return r}_updateArea(e,t,i,s,r){const n=e.renderCoordsHelper,o=this.positionsWorldCoords,a=this.positionsRenderCoords,h=this.positionsProjectedWorldCoords,l=this.positionsFittedRenderCoords,d=this._planeWorldCoords,g=this._centroidRenderCoords;Et(a,g),n.worldUpAtPosition(g,this._worldUp),n.worldBasisAtPosition(g,0,this._worldTangent),S(g,this._worldUp,i,this._worldUp,s),S(g,this._worldTangent,i,this._worldTangent,s),o.length>2&&function(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");m(e[0],e[1],e[2],t)}(o,d),this.fittingMode=this._selectFittingMode(d,o,this._worldUp,r);let _=0;if("horizontal"===this.fittingMode){let e=-1/0;a.forEach(((t,i)=>{const s=n.getAltitude(a[i]);s>e&&(e=s,_=i)}))}const v=o[_];let V=d,x=this._worldTangent;"horizontal"===this.fittingMode?V=this._worldUp:"vertical"===this.fittingMode&&(V=this._tempVec3,x=this._worldUp,E(d,this._worldUp,V)),f(this._frame[2],V),E(x,V,this._frame[0]),y(this._frame[1],this._frame[0],this._frame[2]),D(this._frame[1],this._frame[1]);const w=this._tempVec3,L=this._tempU,b=this._tempV;for(let m=0;m<this._length;++m){const e=h[m],t=l[m];M(w,o[m],v),G(e,c(this._frame[0],w),c(this._frame[1],w)),u(L,this._frame[0],e[0]),u(b,this._frame[1],e[1]),p(w,L,b),p(w,w,v),z(w,s,t,i)}this.perimeterLength=this._length>0?new St(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,Et(l,this.areaCentroidRenderCoords),z(this.areaCentroidRenderCoords,i,this.areaCentroidWorldCoords,s),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new St(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const t=e.renderCoordsHelper,i=this.positionsSpherical,s=this.positionsStereographic,r=this._tempVec3,n=function(e,t=null,i=!0){const s=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let i=0;i<e.length;++i)if(c(t,e[i])<-1e-6)return!1;return!0};if(0===e.length)return!1;if(1===e.length)return t&&f(t,e[0]),!0;d(Nt,0,0,0);for(let r=0;r<e.length;++r)p(Nt,Nt,e[r]);if(_(Nt,Nt),s(e,Nt))return t&&f(t,Nt),!0;if(!i)return!1;for(let r=0;r<e.length;++r)for(let i=0;i<e.length;++i)if(r!==i&&(y(Nt,e[r],e[i]),_(Nt,Nt),s(e,Nt)))return t&&f(t,Nt),!0;return!1}(i,r);if(!n)return void(this.geodesicArea=null);const o=this._tempU,a=this._tempV;T(r,o,a);for(let h=0;h<this._length;++h){const e=c(i[h],o),t=c(i[h],a),n=c(i[h],r);G(s[h],e/n,t/n)}u(r,r,R(e.spatialReference).radius),t.toRenderCoords(r,V(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=n&&0===this.geodesicIntersectingSegments.size?new St(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let i=0;for(let s=0;s<this._length;++s)i+=t[s]=A(e[s],e[(s+1)%this._length]);return i}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const r=e[i],n=e[(i+1)%this._length],o=e[s],a=e[(s+1)%this._length];O(r,n,o,a)&&(t.add(i),t.add(s))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=Xt(e,2),i=this.triangleIndices=new Uint32Array(I(t,[],2));let s=0;for(let r=0;r<i.length;r+=3)s+=qt(e[i[r]],e[i[r+1]],e[i[r+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const r=e[i],n=e[(i+1)%this._length],o=e[s],a=e[(s+1)%this._length];O(r,n,o,a)&&(t.add(i),t.add(s))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=Xt(this.positionsStereographic,2),i=this.geodesicTriangleIndices=new Uint32Array(I(t,[],2));let s=0;for(let r=0;r<i.length;r+=3)s+=Ut(e[i[r]],e[i[r+1]],e[i[r+2]],a.WGS84);return s}_selectFittingMode(e,t,i,s){const r=t.map((t=>Math.abs(function(e,t){return c(e,t)+e[3]}(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);!function(e,t){const i=t.center;d(i,0,0,0);for(let r=0;r<e.length;++r)p(i,i,e[r]);u(i,i,1/e.length);let s=0;for(let r=0;r<e.length;++r)s=Math.max(s,g(i,e[r]));t.radius=Math.sqrt(s)}(t,this._tempSphere);const n=r/(2*this._tempSphere.radius),o=n<s.maxRelativeErrorCoplanar,a=n<s.maxRelativeErrorAlmostCoplanar;let h="horizontal";return o?h="oblique":a&&(h=Math.abs(c(i,e))>Math.cos(k(s.verticalAngleThreshold))?"horizontal":"vertical"),h}}function Xt(e,t){const i=new Float64Array(e.length*t);for(let s=0;s<e.length;++s){const r=e[s];for(let e=0;e<t;++e)i[s*t+e]=r[e]}return i}let Yt=class extends Z{constructor(e){super(e),this._handles=new B}initialize(){const e=this.view.spatialReference,t=V(e),i=t===H?X:t,s=!e||x(e,i)?i:e,r=new Dt(s);this._measurementDataManager=new Ht(this.view,r),this._handles.add([this.layerViewData.path.on("change",(()=>this._update()))]),this._update()}destroy(){this._handles=N(this._handles)}_update(e=!1){const t=this.layerViewData;if(this._measurementDataManager.update(t.path,this.view,t.validMeasurement,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80},e)){const e=this._measurementDataManager.getData();this._set("measurementData",e),t.measurementData=e}}};U([F({constructOnly:!0})],Yt.prototype,"view",void 0),U([F({constructOnly:!0})],Yt.prototype,"analysis",void 0),U([F({readOnly:!0})],Yt.prototype,"measurementData",void 0),U([F({constructOnly:!0})],Yt.prototype,"layerViewData",void 0),Yt=U([W("esri.views.3d.layers.analysis.AreaMeasurement.AreaMeasurementController")],Yt);class $t{constructor(e){this.spatialReference=e}createVector(){return this.tag(P())}pointToVector(e){return this.tag(Y(e.x,e.y))}arrayToVector(e){return this.tag(Y(e[0],e[1]))}vectorToArray(e){return[e[0],e[1]]}pointToArray(e){return[e.x,e.y]}vectorToPoint(e,t=new $){return t.x=e[0],t.y=e[1],t.z=void 0,t.m=void 0,t.spatialReference=this.spatialReference,t}arrayToPoint(e,t=new $){return t.x=e[0],t.y=e[1],t.z=void 0,t.m=void 0,t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}){return t.x=e[0],t.y=e[1],t.z=void 0,t.m=void 0,t.hasZ=!1,t.hasM=!1,t.spatialReference=this.spatialReference,t}lerp(e,t,i,s){return Q(s,e,t,i)}addDelta(e,t,i){e[0]+=t,e[1]+=i}distance(e,t){return A(e,t)}getZ(e,t){return t}hasZ(){return!1}getM(e,t){return t}hasM(){return!1}clone(e){return this.tag(J(e))}copy(e,t){return K(t,e)}fromXYZ(e){return this.tag(Y(e[0],e[1]))}toXYZ(e,t=0){return ee(e[0],e[1],t)}tag(e){return e}}class Qt{constructor(e,t){this.valueType=e,this.spatialReference=t}createVector(){return this.tag(h())}pointToVector(e){return this.tag(ee(e.x,e.y,0===this.valueType?e.z:e.m))}arrayToVector(e){return this.tag(ee(e[0],e[1],e[2]||0))}vectorToArray(e){return[e[0],e[1],e[2]]}pointToArray(e){return 0===this.valueType?[e.x,e.y,e.z]:[e.x,e.y,e.m]}vectorToPoint(e,t=new $){return t.x=e[0],t.y=e[1],t.z=0===this.valueType?e[2]:void 0,t.m=1===this.valueType?e[2]:void 0,t.spatialReference=this.spatialReference,t}arrayToPoint(e,t=new $){return t.x=e[0],t.y=e[1],t.z=0===this.valueType?e[2]:void 0,t.m=1===this.valueType?e[2]:void 0,t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}){const i=0===this.valueType,s=1===this.valueType;return t.x=e[0],t.y=e[1],t.z=i?e[2]:void 0,t.m=s?e[2]:void 0,t.hasZ=i,t.hasM=s,t.spatialReference=this.spatialReference,t}lerp(e,t,i,s){return te(s,e,t,i)}addDelta(e,t,i,s){e[0]+=t,e[1]+=i,0===this.valueType&&(e[2]+=s)}distance(e,t){return 0===this.valueType?C(e,t):A(e,t)}getZ(e,t){return 0===this.valueType?e[2]:t}hasZ(){return 0===this.valueType}getM(e,t){return 1===this.valueType?e[2]:t}hasM(){return 1===this.valueType}clone(e){return this.tag(ie(e))}copy(e,t){return f(t,e)}fromXYZ(e,t=0,i=0){return this.tag(ee(e[0],e[1],0===this.valueType?e.length>2?e[2]:t:i))}toXYZ(e,t=0){return this.tag(ee(e[0],e[1],0===this.valueType?e[2]:t))}tag(e){return e}}class Jt{constructor(e){this.spatialReference=e}createVector(){return this.tag(v())}pointToVector(e){return this.tag(se(e.x,e.y,e.z,e.m))}arrayToVector(e){return this.tag(se(e[0],e[1],e[2]||0,e[3]||0))}vectorToArray(e){return[e[0],e[1],e[2],e[3]]}pointToArray(e){return[e.x,e.y,e.z,e.m]}vectorToPoint(e,t=new $){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.spatialReference=this.spatialReference,t}arrayToPoint(e,t=new $){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t.spatialReference=this.spatialReference,t}lerp(e,t,i,s){return re(s,e,t,i)}addDelta(e,t,i,s){e[0]+=t,e[1]+=i,e[2]+=s}distance(e,t){return C(e,t)}getZ(e){return e[2]}hasZ(){return!0}getM(e){return e[3]}hasM(){return!0}clone(e){return this.tag(ne(e))}copy(e,t){return oe(t,e)}fromXYZ(e,t=0,i=0){return this.tag(se(e[0],e[1],e.length>2?e[2]:t,i))}toXYZ(e){return ee(e[0],e[1],e[2])}tag(e){return e}}function Kt(e,t,i){return e&&t?new Jt(i):t?new Qt(1,i):e?new Qt(0,i):new $t(i)}class ei{constructor(e){this.component=e,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class ti{constructor(e,t,i){this.component=e,this.leftVertex=t,this.rightVertex=i,this.type="edge",t.rightEdge=this,i.leftEdge=this}}class ii{constructor(e,t){this.spatialReference=e,this.viewingMode=t,this.vertices=[],this.edges=[]}unnormalizeVertexPositions(){this.vertices.length<=1||function(e,t){if(!t.supported)return;let i=1/0,s=-1/0;const r=t.upperBoundX-t.lowerBoundX;e.forEach((e=>{let n=e.pos[0];for(;n<t.lowerBoundX;)n+=r;for(;n>t.upperBoundX;)n-=r;i=Math.min(i,n),s=Math.max(s,n),e.pos[0]=n}));const n=s-i;r-n<n&&e.forEach((e=>{e.pos[0]<0&&(e.pos[0]+=r)}))}(this.vertices,function(e,t){const i=ae(e);return 1===t&&i?{supported:!0,lowerBoundX:i.valid[0],upperBoundX:i.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}(this.spatialReference,this.viewingMode))}updateVertexIndex(e,t){if(0===this.vertices.length)return;const i=this.vertices[0];let s=null,r=e,n=t;do{s=r,s.index=n++,r=s.rightEdge?s.rightEdge.rightVertex:null}while(null!=r&&r!==i);s.leftEdge&&s!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(s),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(e,t){const i=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=i}iterateVertices(e){if(0===this.vertices.length)return;const t=this.vertices[0];let i=t;do{e(i,i.index),i=he(i.rightEdge)?i.rightEdge.rightVertex:null}while(i!==t&&null!=i)}}class si extends le{constructor(e,t,i){super(),this.type=e,this.coordinateHelper=t,this.viewingMode=i,this._geometry=null,this.dirty=!0,this.components=[]}get geometry(){if(this.dirty){switch(this.type){case"point":this._geometry=this.toPoint();break;case"polyline":this._geometry=this.toPolyline();break;case"polygon":this._geometry=this.toPolygon()}this.dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}notifyChanges(e){this.dirty=!0,this.emit("change",e)}toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}toPolyline(){const e=[],t=this.coordinateHelper.vectorToArray;return this.components.forEach(((i,s)=>{const r=[];let n=i.vertices.find((e=>null==e.leftEdge));const o=n;do{r.push(t(n.pos)),n=n.rightEdge?n.rightEdge.rightVertex:null}while(n&&n!==o);e.push(r)})),new ce({paths:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}toPolygon(){const e=[],t=this.coordinateHelper.vectorToArray;return this.components.forEach(((i,s)=>{const r=[],n=i.vertices[0];let o=n;const a=o;do{r.push(t(o.pos)),o=he(o.rightEdge)?o.rightEdge.rightVertex:null}while(o&&o!==a);i.isClosed()&&r.push(t(n.pos)),e.push(r)})),new o({rings:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(e,t){const i=e.spatialReference,s=Kt(e.hasZ,e.hasM,i),r=new si(e.type,s,t);switch(e.type){case"polygon":{const n=e.rings;for(let e=0;e<n.length;++e){const o=n[e],a=new ii(i,t),h=o.length>2&&de(o[0],o[o.length-1]),l=h?o.length-1:o.length;for(let e=0;e<l;++e){const t=s.arrayToVector(o[e]),i=new ei(a);a.vertices.push(i),i.pos=t,i.index=e}const c=a.vertices.length-1;for(let e=0;e<c;++e){const t=a.vertices[e],i=a.vertices[e+1],s=new ti(a,t,i);a.edges.push(s)}if(h){const e=new ti(a,a.vertices[a.vertices.length-1],a.vertices[0]);a.edges.push(e)}r.components.push(a)}break}case"polyline":for(const n of e.paths){const e=new ii(i,t),o=n.length;for(let t=0;t<o;++t){const i=s.arrayToVector(n[t]),r=new ei(e);e.vertices.push(r),r.pos=i,r.index=t}const a=e.vertices.length-1;for(let t=0;t<a;++t){const i=e.vertices[t],s=e.vertices[t+1],r=new ti(e,i,s);e.edges.push(r)}r.components.push(e)}break;case"point":{const n=new ii(i,t),o=new ei(n);o.index=0,o.pos=s.pointToVector(e),n.vertices.push(o),r.components.push(n);break}}return r}}class ri{constructor(e,t,i){this.editGeometry=e,this.component=t,this.pos=i,this.addedVertex=null,this.originalEdge=null,this.left=null,this.right=null}apply(){let e="redo";pe(this.addedVertex)&&(e="apply",this.addedVertex=new ei(this.component));const t=this.component.getLastVertex();if(pe(t))this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,this.addedVertex.index=0;else{let e=null;t.rightEdge&&(this.originalEdge=t.rightEdge,e=this.originalEdge.rightVertex,this.component.edges.splice(this.component.edges.indexOf(this.originalEdge),1)),this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,pe(this.left)&&(this.left=new ti(this.component,t,this.addedVertex)),this.component.edges.push(this.left),t.rightEdge=this.left,he(this.originalEdge)&&he(e)&&(pe(this.right)&&(this.right=new ti(this.component,this.addedVertex,e)),this.component.edges.push(this.right),e.leftEdge=this.right),this.component.updateVertexIndex(this.addedVertex,t.index+1)}this.editGeometry.notifyChanges({operation:e,addedVertices:[this.addedVertex]})}undo(){if(pe(this.addedVertex))return null;this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex),1),he(this.left)&&(this.component.edges.splice(this.component.edges.indexOf(this.left),1),this.left.leftVertex.rightEdge=null),he(this.right)&&(this.component.edges.splice(this.component.edges.indexOf(this.right),1),this.right.rightVertex.leftEdge=null),he(this.originalEdge)&&(this.component.edges.push(this.originalEdge),this.originalEdge.leftVertex.rightEdge=this.originalEdge,this.originalEdge.rightVertex.leftEdge=this.originalEdge),he(this.left)?this.component.updateVertexIndex(this.left.leftVertex,this.left.leftVertex.index):this.component.updateVertexIndex(this.addedVertex,0),this.editGeometry.notifyChanges({operation:"undo",removedVertices:[this.addedVertex]})}accumulate(){return!1}}class ni{constructor(e,t,i){this.editGeometry=e,this.vertices=t,this.operation=i,this.undone=!1}apply(){this.vertices.forEach((e=>this.operation.apply(e))),this.editGeometry.components.forEach((e=>e.unnormalizeVertexPositions())),this.editGeometry.notifyChanges({operation:this.undone?"redo":"apply",updatedVertices:this.vertices})}undo(){this.vertices.forEach((e=>this.operation.undo(e))),this.editGeometry.notifyChanges({operation:"undo",updatedVertices:this.vertices}),this.undone=!0}canAccumulate(e){if(this.undone||e.vertices.length!==this.vertices.length)return!1;for(let t=0;t<e.vertices.length;++t)if(e.vertices[t]!==this.vertices[t])return!1;return this.operation.canAccumulate(e.operation)}accumulate(e){return!!(e instanceof ni&&this.canAccumulate(e))&&(this.vertices.forEach((t=>this.operation.accumulate(t,e.operation))),this.operation.accumulateParams(e.operation),this.editGeometry.components.forEach((e=>e.unnormalizeVertexPositions())),this.editGeometry.notifyChanges({operation:"apply",updatedVertices:this.vertices}),!0)}}class oi{constructor(e,t,i=0){this.editGeometry=e,this.vertices=t,this.minNumberOfVertices=i,this.removedVertices=null}apply(){let e="redo";null==this.removedVertices?(this.removedVertices=[],this.vertices.forEach((e=>{const t=this._removeVertex(e);he(t)&&this.removedVertices.push(t)})),e="apply"):this.removedVertices.forEach((e=>{this._removeVertex(e.removedVertex)})),this.editGeometry.notifyChanges({operation:e,removedVertices:this.vertices})}undo(){this.removedVertices.forEach((e=>{this._undoRemoveVertex(e)})),this.editGeometry.notifyChanges({operation:"undo",addedVertices:this.vertices})}accumulate(){return!1}_removeVertex(e){const t=e.component;if(t.vertices.length<=this.minNumberOfVertices)return null;const i={removedVertex:e,createdEdge:null},s=e.leftEdge,r=e.rightEdge;return t.vertices.splice(t.vertices.indexOf(e),1),s&&(t.edges.splice(t.edges.indexOf(s),1),s.leftVertex.rightEdge=null),r&&(t.edges.splice(t.edges.indexOf(r),1),r.rightVertex.leftEdge=null),0===e.index&&r&&this.vertices.length>0&&t.swapVertices(t.vertices.indexOf(r.rightVertex),0),s&&r&&(i.createdEdge=new ti(t,s.leftVertex,r.rightVertex),t.edges.push(i.createdEdge)),r&&t.updateVertexIndex(r.rightVertex,r.rightVertex.index-1),i}_undoRemoveVertex(e){const t=e.removedVertex,i=e.removedVertex.component,s=t.leftEdge,r=t.rightEdge;e.createdEdge&&i.edges.splice(i.edges.indexOf(e.createdEdge),1),i.vertices.push(t),s&&(i.edges.push(s),s.leftVertex.rightEdge=s),r&&(i.edges.push(r),r.rightVertex.leftEdge=r),i.updateVertexIndex(t,t.index)}}class ai{constructor(e,t,i){this.editGeometry=e,this.edge=t,this.t=i,this.createdVertex=null,this.left=null,this.right=null}apply(){let e="redo";const t=this.edge,i=t.component,s=t.leftVertex,r=t.rightVertex;i.edges.splice(i.edges.indexOf(t),1),pe(this.createdVertex)&&(e="apply",this.createdVertex=new ei(t.component)),i.vertices.push(this.createdVertex),this.createdVertex.pos=this.editGeometry.coordinateHelper.lerp(t.leftVertex.pos,t.rightVertex.pos,this.t,this.editGeometry.coordinateHelper.createVector()),pe(this.left)&&(this.left=new ti(i,s,this.createdVertex)),this.left.leftVertex.leftEdge?i.edges.push(this.left):i.edges.unshift(this.left),s.rightEdge=this.left,pe(this.right)&&(this.right=new ti(i,this.createdVertex,r)),i.edges.push(this.right),r.leftEdge=this.right,i.updateVertexIndex(this.createdVertex,s.index+1),this.editGeometry.notifyChanges({operation:e,addedVertices:[this.createdVertex]})}undo(){if(pe(this.createdVertex)||pe(this.left)||pe(this.right))return null;const e=this.edge,t=e.component,i=this.createdVertex.leftEdge,s=this.createdVertex.rightEdge,r=i.leftVertex,n=s.rightVertex;t.vertices.splice(t.vertices.indexOf(this.createdVertex),1),t.edges.splice(t.edges.indexOf(this.left),1),t.edges.splice(t.edges.indexOf(this.right),1),this.edge.leftVertex.leftEdge?t.edges.push(this.edge):t.edges.unshift(this.edge),r.rightEdge=e,n.leftEdge=e,t.updateVertexIndex(r,r.index),this.editGeometry.notifyChanges({operation:"undo",removedVertices:[this.createdVertex]})}accumulate(){return!1}}class hi{constructor(e,t,i){this.editGeometry=e,this.vertex=t,this.pos=i}apply(){const e=pe(this.originalPosition);e&&(this.originalPosition=this.vertex.pos),this._apply(e?"apply":"redo")}undo(){this.vertex.pos=ue(this.originalPosition),this.editGeometry.notifyChanges({operation:"undo",updatedVertices:[this.vertex]})}accumulate(e){return e instanceof hi&&e.vertex===this.vertex&&(this.pos=e.pos,this._apply("apply"),!0)}_apply(e){this.vertex.pos=this.pos,this.editGeometry.components.forEach((e=>e.unnormalizeVertexPositions())),this.editGeometry.notifyChanges({operation:e,updatedVertices:[this.vertex]})}}class li{constructor(e,t){this.editGeometry=e,this.component=t,this.createdEdge=null}apply(){let e="redo";if(pe(this.createdEdge)){e="apply";const t=this.component.getFirstVertex(),i=this.component.getLastVertex();if(this.component.isClosed()||this.component.vertices.length<3||pe(t)||pe(i))return;this.createdEdge=new ti(this.component,i,t)}this.createdEdge.leftVertex.rightEdge=this.createdEdge,this.createdEdge.rightVertex.leftEdge=this.createdEdge,this.component.edges.push(this.createdEdge),this.editGeometry.notifyChanges({operation:e})}undo(){pe(this.createdEdge)||(ge(this.component.edges,this.createdEdge),this.createdEdge.leftVertex.rightEdge=null,this.createdEdge.rightVertex.leftEdge=null,this.editGeometry.notifyChanges({operation:"undo"}))}accumulate(){return!1}}class ci{constructor(e,t,i,s){this.helper=e,this.dx=t,this.dy=i,this.dz=s}move(e,t,i,s){this.helper.addDelta(e.pos,t,i,s)}apply(e){this.move(e,this.dx,this.dy,this.dz)}undo(e){this.move(e,-this.dx,-this.dy,-this.dz)}canAccumulate(e){return e instanceof ci}accumulate(e,t){this.move(e,t.dx,t.dy,t.dz)}accumulateParams(e){this.dx+=e.dx,this.dy+=e.dy,this.dz+=e.dz}}function di(e,t){return e[0]*t[1]-e[1]*t[0]}const pi=1e-6,ui=P(),gi=P(),mi=P(),fi=P();class _i{constructor(e,t,i,s=0,r=0){this.helper=e,this.planeType=t,this.edge=i,this.distance=s,this._plane=_e(),this._offsetPlane=_e(),this._minDistance=-1/0,this._maxDistance=1/0,0===r&&this._initialize()}get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){var e,t,i,s;const r=this._toXYZ(this.edge.leftVertex.pos),n=this._toXYZ(null==(e=this.edge.leftVertex.leftEdge)||null==(t=e.leftVertex)?void 0:t.pos),o=this._toXYZ(this.edge.rightVertex.pos),a=this._toXYZ(null==(i=this.edge.rightVertex.rightEdge)||null==(s=i.rightVertex)?void 0:s.pos);this._edgeDirection=ye(h(),r,o),this._left=this._computeNeighbor(r,n,this._edgeDirection),this._right=this._computeNeighbor(o,a,this._edgeDirection)}_toXYZ(e){return he(e)?this.helper.toXYZ(e):null}_computeNeighbor(e,t,i){if(pe(t))return{start:e,end:t,direction:ee(-i[1],i[0],0),isOriginalDirection:!0};const s=ye(h(),e,t),r=!this._passesBisectingAngleThreshold(s,i);return{start:e,end:t,direction:r?this._bisectVectorsPerpendicular(i,s):s,isOriginalDirection:!r}}_passesBisectingAngleThreshold(e,t){const i=Math.abs(ve(t,e));return i>=yi&&i<=Math.PI-yi}_bisectVectorsPerpendicular(e,t){const i=c(e,t)<0?e:D(h(),e),s=Math.abs(c(i,t));if(!(s<.001||s>.999))return this._bisectDirection(i,t);const r=y(h(),i,[0,0,1]);return _(r,r)}_bisectDirection(e,t){const i=p(h(),e,t);return _(i,i)}_initializePlane(){const e=this._computeNormalDirection(this._left),t=this._computeNormalDirection(this._right);c(e,t)<0&&D(t,t),Ve(this._left.start,this._bisectDirection(e,t),this._plane)}_computeNormalDirection(e){const t=y(h(),e.direction,this._edgeDirection);_(t,t);const i=y(h(),this._edgeDirection,t);return 1===this.planeType&&(i[2]=0),_(i,i)}_initializeDistanceConstraints(){he(this._left.end)&&!this.requiresSplitEdgeLeft&&this._updateDistanceConstraint(xe(this._plane,this._left.end)),he(this._right.end)&&!this.requiresSplitEdgeRight&&this._updateDistanceConstraint(xe(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(e){e<=0&&(this._minDistance=Math.max(this._minDistance,e)),e>=0&&(this._maxDistance=Math.min(this._maxDistance,e))}_updateIntersectDistanceConstraint(e){const t=Ee(e),i=this._edgeDirection,s=p(h(),this._left.start,this._left.direction),r=p(h(),this._right.start,this._right.direction),n=this._pointInBasis2D(P(),t,i,this._left.start),o=this._pointInBasis2D(P(),t,i,s),a=this._pointInBasis2D(P(),t,i,this._right.start),l=this._pointInBasis2D(P(),t,i,r),[c]=function(e,t){const i=e.start,s=e.end,r=t.start,n=t.end,o=me(ui,s,i),a=me(gi,n,r),h=di(o,a);if(Math.abs(h)<=pi)return[];const l=me(mi,i,r),c=di(a,l)/h,d=di(o,l)/h;if(c>=0){if(d>=0||1===t.type)return[fe(fi,i,o,c)]}else if(1===e.type&&(d>=0||1===t.type))return[fe(fi,i,o,c)];return[]}({start:o,end:n,type:1},{start:l,end:a,type:1});if(!c)return;const d=me(P(),n,o);we(d,d);const g=me(P(),c,o),m=Le(d,g),f=p(h(),s,u(h(),this._left.direction,-m)),_=xe(e,f);this._updateDistanceConstraint(_)}_pointInBasis2D(e,t,i,s){return e[0]=be(t,s),e[1]=be(i,s),e}_offset(e,t){Number.isFinite(this._minDistance)&&(t=Math.max(this._minDistance,t)),Number.isFinite(this._maxDistance)&&(t=Math.min(this._maxDistance,t)),Pe(this._plane,this._offsetPlane),this._offsetPlane[3]-=t;const i=(e,t,i)=>he(t)&&Ce(this._offsetPlane,e,p(h(),e,t),i),s=h();(e===this.edge.leftVertex?i(this._left.start,this._left.direction,s):i(this._right.start,this._right.direction,s))&&this.helper.copy(this.helper.fromXYZ(s,void 0,this.helper.getM(e.pos)),e.pos)}signedDistanceToPoint(e){return xe(this.plane,this.helper.toXYZ(this.helper.pointToVector(e)))}apply(e){this._offset(e,this.distance)}undo(e){this._offset(e,0)}canAccumulate(e){return e instanceof _i&&this.edge.leftVertex.index===e.edge.leftVertex.index&&this.edge.rightVertex.index===e.edge.rightVertex.index&&this.edge.component===e.edge.component&&this._maybeEqualsVec3(this._left.direction,e._left.direction)&&this._maybeEqualsVec3(this._right.direction,e._right.direction)&&Se(Ee(this._plane),Ee(e._plane))}accumulate(e,t){const i=this._plane[3]-t._plane[3]+t.distance;this._offset(e,i)}accumulateParams(e){const t=e.distance-e._plane[3];this.distance=t+this._plane[3]}clone(){const e=new _i(this.helper,this.planeType,this.edge,this.distance,1);return Pe(this._plane,e._plane),Pe(this._offsetPlane,e._offsetPlane),e._maxDistance=this._maxDistance,e._minDistance=this._minDistance,e._left=this._cloneNeighbor(this._left),e._right=this._cloneNeighbor(this._right),e._edgeDirection=f(h(),this._edgeDirection),e}_maybeEqualsVec3(e,t){return pe(e)&&pe(t)||he(e)&&he(t)&&Se(e,t)}_cloneNeighbor({start:e,end:t,direction:i,isOriginalDirection:s}){return{start:f(h(),e),end:he(t)?f(h(),t):null,direction:f(h(),i),isOriginalDirection:s}}}const yi=k(15);class vi{constructor(e,t,i=0){this.origin=e,this.angle=t,this.accumulationType=i}rotate(e,t){De(e.pos,e.pos,this.origin,t)}apply(e){this.rotate(e,this.angle)}undo(e){this.rotate(e,-this.angle)}canAccumulate(e){return e instanceof vi&&de(this.origin,e.origin)}accumulate(e,t){const i=1===t.accumulationType;this.rotate(e,i?t.angle-this.angle:t.angle)}accumulateParams(e){const t=1===e.accumulationType;this.angle=t?e.angle:this.angle+e.angle}}class Vi{constructor(e,t,i,s,r=0){this.origin=e,this.axis1=t,this.factor1=i,this.factor2=s,this.accumulationType=r,this.axis2=Y(t[1],-t[0])}scale(e,t,i){Me(e.pos,e.pos,this.origin,this.axis1,t),Me(e.pos,e.pos,this.origin,this.axis2,i)}apply(e){this.scale(e,this.factor1,this.factor2)}undo(e){this.scale(e,1/this.factor1,1/this.factor2)}canAccumulate(e){return e instanceof Vi&&de(this.origin,e.origin)&&de(this.axis1,e.axis1)}accumulate(e,t){1===t.accumulationType?this.scale(e,t.factor1/this.factor1,t.factor2/this.factor2):this.scale(e,t.factor1,t.factor2)}accumulateParams(e){const t=1===e.accumulationType;this.factor1=t?e.factor1:this.factor1*e.factor1,this.factor2=t?e.factor2:this.factor2*e.factor2}}class xi{constructor(){this.operations=[],this.closed=!1}close(){this.closed=!0}apply(){for(const e of this.operations)e.apply()}undo(){for(let e=this.operations.length-1;e>=0;e--)this.operations[e].undo()}accumulate(e){if(this.closed)return!1;const t=this.operations.length?this.operations[this.operations.length-1]:null;return t&&t.accumulate(e)||(this.operations.push(e),e.apply()),!0}}class wi extends le{constructor(e){super(),this.data=e,this.undoStack=[],this.redoStack=[],this.listener=this.data.on("change",(e=>{e.addedVertices&&this.emit("vertex-add",{type:"vertex-add",vertices:e.addedVertices,operation:e.operation}),e.removedVertices&&this.emit("vertex-remove",{type:"vertex-remove",vertices:e.removedVertices,operation:e.operation}),e.updatedVertices&&this.emit("vertex-update",{type:"vertex-update",vertices:e.updatedVertices,operation:e.operation})}))}destroy(){this.listener.remove()}splitEdge(e,t){return this.apply(new ai(this.data,e,t))}updateVertices(e,t,i=1){return this.apply(new ni(this.data,e,t),i)}moveVertices(e,t,i,s,r=1){return this.updateVertices(e,new ci(this.data.coordinateHelper,t,i,s),r)}scaleVertices(e,t,i,s,r,n=1,o=0){return this.updateVertices(e,new Vi(t,i,s,r,o),n)}rotateVertices(e,t,i,s=1,r=0){return this.updateVertices(e,new vi(t,i,r),s)}removeVertices(e){return this.apply(new oi(this.data,e,this._minNumVerticesPerType))}appendVertex(e){return 0===this.data.components.length?null:this.apply(new ri(this.data,this.data.components[0],e))}setVertexPosition(e,t){return this.apply(new hi(this.data,e,t))}offsetEdge(e,t,i,s=1){return this.updateVertices([t.leftVertex,t.rightVertex],new _i(this.data.coordinateHelper,e,t,i),s)}closeComponent(e){return this.data.components.includes(e)?this.apply(new li(this.data,e)):null}canRemoveVertex(){return this.data.components[0].vertices.length>this._minNumVerticesPerType}createUndoGroup(){const e=new xi;return this.apply(e),{remove:()=>e.close()}}undo(){if(this.undoStack.length>0){const e=this.undoStack.pop();return e.undo(),this.redoStack.push(e),e}return null}redo(){if(this.redoStack.length>0){const e=this.redoStack.pop();return e.apply(),this.undoStack.push(e),e}return null}get canUndo(){return this.undoStack.length>0}get canRedo(){return this.redoStack.length>0}get lastOperation(){return this.undoStack.length>0?this.undoStack[this.undoStack.length-1]:null}get _minNumVerticesPerType(){switch(this.data.type){case"point":return 1;case"polyline":return 2;case"polygon":return 3;default:return 0}}apply(e,t=1){return 0!==t&&!pe(this.lastOperation)&&this.lastOperation.accumulate(e)||(e.apply(),this.undoStack.push(e),this.redoStack=[]),e}static fromGeometry(e,t){return new wi(si.fromGeometry(e,t))}}let Li=class extends le.EventedAccessor{constructor(e={}){super(e),this._handles=new B,this._version=0,this._internalGeometryChange=!1,this._extent=Ge()}destroy(){this._handles=N(this._handles)}set areaMeasurement(e){this._set("areaMeasurement",e),he(e)&&he(this.view)&&this._initialize(e,this.view)}set view(e){this._set("view",e),he(e)&&he(this.areaMeasurement)&&this._initialize(this.areaMeasurement,e)}get initialized(){return he(this.areaMeasurement)&&he(this.view)}get version(){return this._version}get isValidPolygon(){return this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].isClosed()}get extent(){if(this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].vertices.length>0){const e=Ge(this._extent);return this.forEachVertex((t=>{ze(e,t.pos)})),e}return null}get spatialReference(){return this.initialized?this.editGeometry.coordinateHelper.spatialReference:null}_initialize(e,t){this._handles.removeAll(),this._handles.add(Te(e,"geometry",(()=>this._updateEditGeometryFromModelGeometry(e,t)),!0)),this._makeDirty(!0)}_makeDirty(e=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),this.notifyChange("extent"),e&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(e,t){this._version++,this._internalGeometryChange||(this._handles.remove("EditGeometry"),he(e.geometry)?this._editGeometryOperations=wi.fromGeometry(e.geometry,t.state.viewingMode):this._editGeometryOperations=new wi(new si("polygon",Kt(!0,!1,t.spatialReference),t.state.viewingMode)),this._makeDirty(!0),this.emit("change",{type:"change"}),this._handles.add(this.editGeometry.on("change",(t=>{this._makeDirty(null!=t.addedVertices||null!=t.removedVertices),this._internalGeometryChange=!0,e.geometry=this.numVertices>0?this.editGeometry.geometry:null,this._internalGeometryChange=!1})),"EditGeometry"))}get editGeometry(){return this._editGeometryOperations.data}get vertices(){const e=[];return this.forEachVertex((t=>{e.push(t)})),e}get numVertices(){return this.initialized&&this.editGeometry.components.length>0?this.editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.initialized&&this.editGeometry.components.length>0){const e=this.editGeometry.components[0].getLastVertex();if(he(e))return this.editGeometry.coordinateHelper.vectorToPoint(e.pos)}return null}getVertex(e){if(!this.initialized||0===this.editGeometry.components.length||0===this.editGeometry.components[0].vertices.length)return null;const t=this.editGeometry.components[0].vertices[0];let i=t;do{if(i.index===e)return i;i=i.rightEdge.rightVertex}while(i!==t&&null!=i);return null}getVertexPositionAsPoint(e){return this.editGeometry.coordinateHelper.vectorToPoint(e.pos)}getVertexPositionAsPointFromIndex(e){return this.editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e).pos)}forEachVertex(e){this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].iterateVertices(e)}forEachVertexPosition(e){const t=this.editGeometry.coordinateHelper;this.forEachVertex(((i,s)=>{t.vectorToPoint(i.pos,bi),e(bi,s)}))}clear(){he(this.areaMeasurement)&&(this.areaMeasurement.geometry=null)}add(e){if(!this.initialized)return null;if(0===this.editGeometry.components.length){const e=ue(this.view);this.editGeometry.components.push(new ii(e.spatialReference,e.state.viewingMode))}const t=this._editGeometryOperations.appendVertex(this.editGeometry.coordinateHelper.pointToVector(e));return this.emit("change",{type:"change"}),t}close(){if(!this.initialized||0===this.editGeometry.components.length)return null;const e=this._editGeometryOperations.closeComponent(this.editGeometry.components[0]);return this.emit("change",{type:"change"}),e}ensureContains(e,t=""){let i=!1;if(this.editGeometry.components.forEach((t=>{t.iterateVertices((t=>{t===e&&(i=!0)}))})),!i)throw new Error(`vertex doesnt exist ${t}`);return i}setVertexPosition(e,t){if(!this.initialized)return null;const i=this._editGeometryOperations.setVertexPosition(e,this.editGeometry.coordinateHelper.pointToVector(t));return this.emit("change",{type:"change"}),i}equals(e){if(this.numVertices!==e.numVertices)return!1;let t=!0;return this.forEachVertexPosition(((i,s)=>{const r=e.getVertexPositionAsPointFromIndex(s);i.equals(r)||(t=!1)})),!!t}};U([F({value:null})],Li.prototype,"areaMeasurement",null),U([F({value:null})],Li.prototype,"view",null),U([F()],Li.prototype,"isValidPolygon",null),U([F()],Li.prototype,"extent",null),U([F()],Li.prototype,"spatialReference",null),U([F()],Li.prototype,"numVertices",null),Li=U([W("esri.views.3d.interactive.graphics.AreaMeasurement3D.AreaMeasurement3DPathHelper")],Li);const bi=new $;let Pi=class extends Z{constructor(){super(...arguments),this.measurementData=null,this.unitNormalizer=new Dt,this.path=new Li,this.lastDraggedVertex=null}destroy(){this.measurementData=null,this.path=N(this.path)}get validMeasurement(){return this.path.isValidPolygon}};var Ci,Si;U([F()],Pi.prototype,"measurementData",void 0),U([F()],Pi.prototype,"validMeasurement",null),U([F()],Pi.prototype,"unitNormalizer",void 0),U([F()],Pi.prototype,"path",void 0),U([F()],Pi.prototype,"lastDraggedVertex",void 0),U([F()],Pi.prototype,"cursorPoint",void 0),Pi=U([W("esri.views.3d.layers.analysis.AreaMeasurement3D.AreaMeasurementLayerViewData")],Pi),(Si=Ci||(Ci={})).boundingSphere=function(e,t){const i=t.center;d(i,0,0,0);for(let r=0;r<e.length;++r)p(i,i,e[r]);u(i,i,1/e.length);let s=0;for(let r=0;r<e.length;++r)s=Math.max(s,g(i,e[r]));t.radius=Math.sqrt(s)},Si.bestFitPlane=function(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");m(e[0],e[1],e[2],t)},Si.planePointDistance=function(e,t){return c(e,t)+e[3]},Si.segmentLengthEuclidean=function(e,t,i){return L(e,Ei,i)&&L(t,Di,i)?C(Ei,Di):0},Si.segmentLengthGeodesic=function(e,t){if(!b(e,Ei)||!b(t,Di))return 0;const i={distance:null};return Ct(i,[Ei[0],Ei[1]],[Di[0],Di[1]]),i.distance},Si.segmentLengthGeodesicVector=function(e,t,i){const s={distance:null};return Ct(s,[e[0],e[1]],[t[0],t[1]],i),s.distance},Si.triangleAreaEuclidean=function(e,t,i){const s=t[0]-e[0],r=t[1]-e[1],n=i[0]-e[0],o=i[1]-e[1];return.5*Math.abs(s*o-r*n)},Si.triangleAreaGeodesic=function(e,t,i,s){const r=Gi;return l(e,s,Ei)&&l(t,s,Di)&&l(i,s,Mi)?(r.setPoint(0,0,Ei),r.setPoint(0,1,Di),r.setPoint(0,2,Mi),Math.abs(Ot(r,"square-meters"))):0},Si.tangentFrame=function(e,t,i){Math.abs(e[0])>Math.abs(e[1])?d(t,0,1,0):d(t,1,0,0),y(i,e,t),_(t,t),y(t,i,e),_(i,i)},Si.fitHemisphere=function(e,t=null,i=!0){const s=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let i=0;i<e.length;++i)if(c(t,e[i])<-1e-6)return!1;return!0};if(0===e.length)return!1;if(1===e.length)return t&&f(t,e[0]),!0;d(zi,0,0,0);for(let r=0;r<e.length;++r)p(zi,zi,e[r]);if(_(zi,zi),s(e,zi))return t&&f(t,zi),!0;if(!i)return!1;for(let r=0;r<e.length;++r)for(let i=0;i<e.length;++i)if(r!==i&&(y(zi,e[r],e[i]),_(zi,zi),s(e,zi)))return t&&f(t,zi),!0;return!1},Si.compareSets=function(e,t){if(e===t)return!0;if(e.size!==t.size)return!1;for(let i=0;i<e.size;++i)if(!t.has(e[i]))return!1;return!0},Si.isPrimaryPointerAction=function(e){return"mouse"!==e.pointerType||0===e.button};const Ei=h(),Di=h(),Mi=h(),Gi=new o({rings:[[Ei,Di,Mi]],spatialReference:a.WGS84}),zi=h();var Ti=Ci;function Ri(e){const t=new Re;return t.extensions.add("GL_OES_standard_derivatives"),t.attributes.add("position","vec3"),t.attributes.add("uv0","vec2"),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.varyings.add("vUV","vec2"),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),t.vertex.code.add(Ae`
    void main(void) {
      vUV = uv0;
      ${e.multipassTerrainEnabled?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),e.multipassTerrainEnabled&&(t.fragment.include(Oe),t.include(Ie,e)),t.fragment.uniforms.add("size","vec2").add("color1","vec4").add("color2","vec4"),t.fragment.include(ke),t.fragment.code.add(Ae`
    void main() {
      ${e.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${e.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),t}var Ai=Object.freeze({__proto__:null,build:Ri});class Oi extends Fe{initializeProgram(e){const t=Oi.shader.get(),i=this.configuration,s=t.build({OITEnabled:0===i.transparencyPassType,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new We(e.rctx,s,Ze)}bindPass(e,t){Be(this.program,t.camera.projectionMatrix),this.program.setUniform2fv("size",e.size),this.program.setUniform4fv("color1",e.color1),this.program.setUniform4fv("color2",e.color2),t.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),this.program.setUniform2fv("inverseViewport",t.inverseViewport),Ne(this.program,t))}bindDraw(e){He(this.program,e)}setPipelineState(e){const t=this.configuration,i=3===e,s=2===e;return Xe({blending:t.transparent?i?ki:Ye(e):null,depthTest:{func:$e(e)},depthWrite:i?t.writeDepth&&Qe:Je(e),colorWrite:Ke,polygonOffset:i||s?t.polygonOffset&&Ii:{factor:-1,units:-25}})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}Oi.shader=new je(Ai,(()=>import("./CheckerBoard.glsl.fad13c7b.js")));const Ii={factor:0,units:-25},ki=qe(770,1,771,771);class ji extends et{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}U([Ue()],ji.prototype,"transparent",void 0),U([Ue()],ji.prototype,"writeDepth",void 0),U([Ue()],ji.prototype,"polygonOffset",void 0),U([Ue({count:4})],ji.prototype,"transparencyPassType",void 0),U([Ue()],ji.prototype,"multipassTerrainEnabled",void 0),U([Ue()],ji.prototype,"cullAboveGround",void 0);class qi extends tt{constructor(e){super(e,Fi),this.techniqueConfig=new ji}dispose(){}getPassParameters(){return this.params}getTechniqueConfig(e){return this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.transparencyPassType=e?e.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!e&&e.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!e&&e.cullAboveGround,this.techniqueConfig}intersect(e,t,i,s,r,n,o){return it(e,t,s,r,n,void 0,o)}getGLMaterial(e){return 0===e.output||7===e.output?new Ui(e):void 0}createBufferWriter(){return new st(rt)}}class Ui extends nt{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(Oi,this._material.getTechniqueConfig(e),this._technique)}beginSlot(e){let t=3;return this._technique.configuration.transparent&&(t=this._technique.configuration.writeDepth?5:8),e===t||23===e}ensureParameters(e){this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}}const Fi=n({size:[1,1],color1:[.75,.75,.75,1],color2:[.5,.5,.5,1],transparent:!1,writeDepth:!0,polygonOffset:!1},ot);class Wi extends It{constructor(e){super(e),this._checkerBoardMaterial=null,this._renderOccluded=4,this._geometry=null,this._size=[1,1],this._color1=se(1,.5,0,.5),this._color2=se(1,1,1,.5),this.applyProps(e)}get renderOccluded(){return this._renderOccluded}set renderOccluded(e){e!==this._renderOccluded&&(this._renderOccluded=e,this.updateMaterial())}get geometry(){return this._geometry}set geometry(e){this._geometry=e,this.geometryChanged()}get size(){return this._size}set size(e){this._size=e,this.updateMaterial()}get color1(){return this._color1}set color1(e){at(e,this._color1)||(oe(this._color1,e),this.updateMaterial())}get color2(){return this._color2}set color2(e){at(e,this._color2)||(oe(this._color2,e),this.updateMaterial())}updateMaterial(){he(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameterValues({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new qi({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:4})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(e){he(this._checkerBoardMaterial)&&e(this._checkerBoardMaterial)}createGeometries(e){if(pe(this._geometry)||pe(this._checkerBoardMaterial))return;const t=Zi;ht(t,this.transform);const i=this._geometry,s=[],r=h();i.position.forEach((e=>{M(r,e,t),s.push(r[0],r[1],r[2])}));const n=[];i.uv.forEach((e=>{n.push(e[0],e[1])}));const o=new lt([["position",{size:3,data:s,exclusive:!0}],["uv0",{size:2,data:n,exclusive:!0}]],[["position",i.triangleIndices],["uv0",i.triangleIndices]]);e.addGeometry(o,this._checkerBoardMaterial)}geometryChanged(){this.recreateGeometry()}}const Zi=h();let Bi=class extends Z{constructor(e){super(e),this._handles=new B,this._params=n({},Ni),this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=h(),this._originTransform=ct(),this._cursorPositionRenderSpace=h(),this.messages=null,this.viewData=Hi,this.areaLabel=null,this.perimeterLengthLabel=null,this.mode=0,this.loadingMessages=!0,this.geodesicMeasurementDistanceThreshold=1e5}get visible(){return this.layerView.visible&&!this.layerView.suspended}get testData(){return{labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}initialize(){const e=this.view,t=this._params;this._path=new kt({view:e,attached:!0,width:t.pathLineWidth,color:t.pathLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPath=new kt({view:e,attached:!0,width:t.pathLineWidth,color:t.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._perimeter=new kt({view:e,attached:!0,width:t.perimeterLineWidth,color:t.perimeterLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPerimeter=new kt({view:e,attached:!0,width:t.perimeterLineWidth,color:t.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._projectionLines=new kt({view:e,attached:!0,width:t.projectionLineWidth,color:t.projectionLineColor,stipplePattern:dt(t.projectionLineStippleSize),stippleIntegerRepeats:!1,polygonOffset:!0,renderOccluded:4}),this._measurementArea=new Wi({view:e,attached:!0,color1:t.areaColor1,color2:t.areaColor2}),this._areaLabel=new Mt({view:this.view,attached:!0,fontSize:16}),this._pathLengthLabel=new Mt({view:e,attached:!0,fontSize:12}),this._cursorSegmentLengthLabel=new Mt({view:e,attached:!0,fontSize:12}),this._perimeterLengthLabel=new Mt({view:e,attached:!0,fontSize:12});const i=this.layerView,s=i.layerViewData;this._handles.add([pt((()=>[this.mode,this.visible,i.unit,s.measurementData,s.cursorPoint]),(()=>this._update())),pt((()=>{var t;return null==(t=e.state)?void 0:t.camera}),(()=>this._updateLabels())),ut((async()=>this._updateMessageBundle())),pt((()=>this.layerView.fullOpacity),(()=>this._updateVisualElementsOpacity()))]),this._updateMessageBundle()}destroy(){this._measurementArea=N(this._measurementArea),this._path=N(this._path),this._intersectedPath=N(this._intersectedPath),this._perimeter=N(this._perimeter),this._intersectedPerimeter=N(this._intersectedPerimeter),this._areaLabel=N(this._areaLabel),this._pathLengthLabel=N(this._pathLengthLabel),this._cursorSegmentLengthLabel=N(this._cursorSegmentLengthLabel),this._perimeterLengthLabel=N(this._perimeterLengthLabel),this._handles=N(this._handles),this.set("view",null)}_update(){if(this.destroyed)return;const e=this.layerView.layerViewData.measurementData;pe(e)||(this._updateViewData(e,this.layerView.layerViewData.path,this.layerView.layerViewData.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(e,t,i){const s=t.isValidPolygon,r=t.lastPoint,n=he(r)&&he(i)?new St(Ti.segmentLengthGeodesic(r,i),"meters"):null,o=he(r)&&he(i)?new St(e.unitNormalizer.normalizeDistance(Ti.segmentLengthEuclidean(r,i,e.unitNormalizer.spatialReference)),"meters"):null;let a=this.mode;0===this.mode&&(a=1,(e.geodesicPathLength?e.geodesicPathLength.value:0)+(!s&&he(n)?n.value:0)>this.geodesicMeasurementDistanceThreshold&&(a=2)),null==e.geodesicPathLength&&(a=1);const h=2===a,l=h?e.geodesicArea:e.area;let c=1;if(l){const t=this._toPreferredAreaUnit(l,this.layerView.unit);c=gt(Math.sqrt(t.value)/Math.sqrt(300)),c*=Math.sqrt(mt(1,t.unit,"square-meters")),c/=e.unitNormalizer.normalizeDistance(1)}const d={validMeasurement:s,path:t,pathVersion:t.version,cursorPoint:i,measurementData:e,mode:a,positionsGeographic:e.positionsGeographic,positionsRenderCoords:e.positionsRenderCoords,positionsProjected:e.positionsProjectedWorldCoords,positionsFittedRenderCoords:e.positionsFittedRenderCoords,intersectingSegments:h?e.geodesicIntersectingSegments:e.intersectingSegments,triangleIndices:h?e.geodesicTriangleIndices:e.triangleIndices,fittingMode:e.fittingMode,areaCentroid:h?e.geodesicAreaCentroidRenderCoords:e.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:s?0:t.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:c,geodesicCursorSegmentLength:n,cursorSegmentLength:o};this._set("viewData",d)}_updateOrigin(){const e=this.viewData;Gt(e.positionsRenderCoords,this._origin),ft(this._originTransform),_t(this._originTransform,this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(e){const t=this.viewData,i=t.path,s=this.view.renderCoordsHelper.spatialReference,r=t.mode,n=[],o=[],a=[],h=t.validMeasurement?i.numVertices:i.numVertices-1;for(let l=0;l<h;++l){const h=t[e][l],c=t[e][(l+1)%i.numVertices];let d=null;switch(r){case 1:d=new Rt(h,c);break;case 2:d=new zt(h,c,s)}t.intersectingSegments.has(l)?a.push(d):o.push(d),n.push(d)}return{all:n,nonIntersecting:o,intersecting:a}}_updatePathSegments(){const e=this.visible,t=this.viewData,i=this._createSegments("positionsRenderCoords"),s=t.path,r=!s.isValidPolygon,n=t.cursorPoint,o=this.view.renderCoordsHelper,a=o.spatialReference,h=t.mode;if(this._cursorSegment=null,s.numVertices>0&&r&&he(n)&&o.toRenderCoords(n,this._cursorPositionRenderSpace)){const e=t.positionsRenderCoords[s.numVertices-1],r=this._cursorPositionRenderSpace;let n=null;switch(h){case 1:n=new Rt(e,r);break;case 2:n=new zt(e,r,a)}i.nonIntersecting.push(n),this._cursorSegment=n}this._path.setGeometryFromSegments(i.nonIntersecting,this._origin),this._path.visible=e,this._intersectedPath.setGeometryFromSegments(i.intersecting,this._origin),this._intersectedPath.visible=e,this._pathSegments=i.all}_updatePerimeterSegments(){const e=this.visible&&1===this.viewData.mode,t=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(t.nonIntersecting,this._origin),this._perimeter.visible=e,this._intersectedPerimeter.setGeometryFromSegments(t.intersecting,this._origin),this._intersectedPerimeter.visible=e,this._perimeterSegments=t.all}_updateArea(){const e=this.viewData;switch(e.mode){case 1:this._updateAreaEuclidean(e);break;case 2:this._updateAreaGeodesic()}}_updateAreaEuclidean(e){const t=this.visible;e.validMeasurement&&0===e.intersectingSegments.size&&e.triangleIndices?(this._measurementArea.geometry={uv:e.positionsProjected,position:e.positionsFittedRenderCoords,triangleIndices:e.triangleIndices},this._measurementArea.size=[e.checkerSize,e.checkerSize],this._measurementArea.visible=t):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const e=this.viewData,t=this.visible,i=e.path,s=e.mode;if(i.numVertices>0&&e.validMeasurement&&1===s){const s=[];for(let t=0;t<i.numVertices;++t){const i=h();M(i,e.positionsRenderCoords[t],this._origin);const r=h();M(r,e.positionsFittedRenderCoords[t],this._origin),s.push([i,r])}this._projectionLines.geometry=s,this._projectionLines.visible=t}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const e=this.viewData,t=e.path;if(!t)return;const i=e.measurementData,s=e.mode,r=!t.isValidPolygon,n=this.visible,o=this._formatAreaLabel(this.messages,2===s?i.geodesicArea:i.area,this.layerView.unit);he(o)?(this._areaLabel.geometry={type:"point",point:e.areaCentroid},this._areaLabel.text=o,this._areaLabel.visible=e.validMeasurement&&0===e.intersectingSegments.size&&n):this._areaLabel.visible=!1,this._set("areaLabel",ue(o));const a=this._formatLengthLabel(this.messages,2===s?i.geodesicPathLength:i.pathLength,this.layerView.unit);if(he(a)&&e.pathLengthLabelSegmentIndex>=0&&e.pathLengthLabelSegmentIndex<this._pathSegments.length){const i=this._pathSegments[e.pathLengthLabelSegmentIndex],s=he(this._cursorSegment)?this._cursorSegment:Xi;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:i,right:s},this._pathLengthLabel.text=a,this._pathLengthLabel.visible=r&&t.numVertices>0&&n}else this._pathLengthLabel.visible=!1;const h=2===s?e.geodesicCursorSegmentLength:e.cursorSegmentLength;if(he(h)){const e=this._formatLengthLabel(this.messages,h,this.layerView.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=he(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=ue(e),this._cursorSegmentLengthLabel.visible=r&&0!==h.value&&n}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const l=2===e.mode,c=l?i.geodesicPathLength:i.perimeterLength,d=ue(null!=c?this._formatLengthLabel(this.messages,c,this.layerView.unit):null);if(this._set("perimeterLengthLabel",ue(d)),e.validMeasurement&&0===e.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=d,this._perimeterLengthLabel.visible=!0;let t=!0;for(let i=0;i<e.path.numVertices;++i){const s=(e.perimeterLengthLabelSegmentIndex+i)%e.path.numVertices,r=l?this._pathSegments[s]:this._perimeterSegments[s];if(t=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:r,sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;t=!1}this._perimeterLengthLabel.visible=t&&n}else this._perimeterLengthLabel.visible=!1}_toPreferredAreaUnit(e,t){return e.toUnit(this._preferredAreaUnit(e,t))}_preferredAreaUnit(e,t){switch(t){case"metric":return vt(e.value,e.unit);case"imperial":return yt(e.value,e.unit);default:return t}}_preferredLengthUnit(e,t){const i=this._deriveLengthUnitFromAreaUnit(t);switch(i){case"metric":return xt(e.value,e.unit);case"imperial":return Vt(e.value,e.unit);default:return i}}_deriveLengthUnitFromAreaUnit(e){switch(e){case"metric":return"metric";case"imperial":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers";case"acres":return"imperial";case"ares":case"hectares":return"metric"}throw new Error("unhandled area unit")}_formatAreaLabel(e,t,i){return e&&t&&Tt(e,t,this._preferredAreaUnit(t,i))}_formatLengthLabel(e,t,i){return e&&t&&Tt(e,t,this._preferredLengthUnit(t,i))}_updateMessageBundle(){this.loadingMessages=!0,wt("esri/core/t9n/Units").then((e=>{this.messages=e,this.view&&this._update()})).finally((()=>{this.loadingMessages=!1}))}_updateVisualElementsOpacity(){const e=this.layerView.fullOpacity,{pathLineColor:t,intersectingLineColor:i,perimeterLineColor:s,projectionLineColor:r,areaColor1:n,areaColor2:o}=this._params;this._path.color=Lt(Yi,t,e),Lt(Yi,i,e),this._intersectedPath.color=Yi,this._intersectedPerimeter.color=Yi,this._perimeter.color=Lt(Yi,s,e),this._projectionLines.color=Lt(Yi,r,e),this._measurementArea.color1=Lt(Yi,n,e),this._measurementArea.color2=Lt(Yi,o,e)}};U([F()],Bi.prototype,"view",void 0),U([F()],Bi.prototype,"messages",void 0),U([F()],Bi.prototype,"analysis",void 0),U([F()],Bi.prototype,"viewData",void 0),U([F()],Bi.prototype,"layerView",void 0),U([F({readOnly:!0})],Bi.prototype,"areaLabel",void 0),U([F({readOnly:!0})],Bi.prototype,"perimeterLengthLabel",void 0),U([F()],Bi.prototype,"mode",void 0),U([F()],Bi.prototype,"loadingMessages",void 0),U([F({readOnly:!0})],Bi.prototype,"visible",null),U([F()],Bi.prototype,"geodesicMeasurementDistanceThreshold",void 0),Bi=U([W("esri.views.3d.layers.analysis.AreaMeasurement.AreaMeasurementView")],Bi);const Ni={laserLineGlowColor:[1,.5,0],laserLineGlowWidth:8,laserLineGlowFalloff:8,laserLineInnerColor:[1,1,1],laserLineInnerWidth:1,laserLineGlobalAlpha:.75,laserLineEnabled:!0,handleColor:[1,.5,0],handleOpacity:.5,handleRadius:5,handleRadiusHovered:10,handleRadiusMouse:10,handleRadiusTouch:25,pathLineColor:[1,.5,0,1],pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:[1,.5,0,1],perimeterLineWidth:2,projectionLineColor:[1,.5,0,1],projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:[1,.5,0,.5],areaColor2:[1,1,1,.5],fillColor:[1,.5,0,.5],lineSubdivisions:64,labelDistance:25},Hi={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null,geodesicCursorSegmentLength:null,cursorSegmentLength:null},Xi=new Rt(h(),h()),Yi=v();let $i=class extends(bt(Pt)){constructor(e){super(e),this.type="area-measurement-3d",this.layerViewData=new Pi,this._userUnit=null}set unit(e){this._userUnit=e}get unit(){return j(this._userUnit,this._defaultUnit)}get result(){if(he(this.layerViewData.measurementData)){const e=this.layerViewData.measurementData;return{area:e.area,geodesicArea:e.geodesicArea,pathLength:e.pathLength,geodesicPathLength:e.geodesicPathLength,perimeterLength:e.perimeterLength}}return{area:null,geodesicArea:null,pathLength:null,geodesicPathLength:null,perimeterLength:null}}initialize(){this.layerViewData.path.view=this.view,this.layerViewData.path.areaMeasurement=this.layer,this.analysisView=new Bi({view:this.view,analysis:this.layer,layerView:this}),this.analysisController=new Yt({view:this.view,analysis:this.layer,layerViewData:this.layerViewData})}destroy(){this.analysisController=N(this.analysisController),this.analysisView=N(this.analysisView),this.layerViewData=N(this.layerViewData)}isUpdating(){var e;return!(null==(e=this.analysisView)||!e.loadingMessages)}get testData(){return{view:this.analysisView,controller:this.analysisController}}};U([F()],$i.prototype,"type",void 0),U([F()],$i.prototype,"analysisView",void 0),U([F()],$i.prototype,"analysisController",void 0),U([F()],$i.prototype,"unit",null),U([F()],$i.prototype,"layer",void 0),U([F()],$i.prototype,"result",null),U([F()],$i.prototype,"layerViewData",void 0),U([F(At)],$i.prototype,"_defaultUnit",void 0),U([F()],$i.prototype,"_userUnit",void 0),$i=U([W("esri.views.3d.layers.AreaMeasurementLayerView3D")],$i);var Qi=$i,Ji=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",default:Qi});export{Ji as A,Ri as o};
//# sourceMappingURL=AreaMeasurementLayerView3D.37d21f35.js.map
