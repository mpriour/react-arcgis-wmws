var e=Object.defineProperty,t=Object.defineProperties,n=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,i=(t,n,r)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,a=(e,t)=>{for(var n in t||(t={}))o.call(t,n)&&i(e,n,t[n]);if(r)for(var n of r(t))s.call(t,n)&&i(e,n,t[n]);return e};import{bb as l,B as c,lb as f,cn as u,hj as p,aL as h,oH as g,oI as m,hG as d,aj as x,bj as y,M as v,z as w,fF as b,gJ as A,gY as R,jU as F,jD as M,g$ as O,h0 as j,h1 as P,gS as L,gW as z,gX as C,gE as S,g_ as I,oJ as k,oK as $,lj as U,fD as E,ko as T,lU as B,lp as D,gB as G,gF as Z,cq as N,I as J,j2 as X,aN as Y,oL as q,P as W,aO as V,oM as H,F as _,G as K,H as Q,cs as ee,b4 as te,D as ne}from"./vendor.7103ff48.js";import{r as re,k as oe,x as se,b as ie,a as ae,q as le,v as ce,c as fe,d as ue,O as pe}from"./georeference.6f09914a.js";const he=l.getLogger("esri.geometry.support.meshUtils.centerAt");function ge(e,t,n){var r;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const o=null!=(r=null==n?void 0:n.origin)?r:e.origin;c(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&he.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,n){const r=t.x-n.x,o=t.y-n.y,s=t.hasZ&&n.hasZ?t.z-n.z:0,i=e.origin;e.origin=[i[0]+r,i[1]+o,i[2]+s]}(e.transform,t,o)):re(e.spatialReference,n)?function(e,t,n){const r=oe(e.vertexAttributes,n,{geographic:!0}),{position:o,normal:s,tangent:i}=se(r,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=s,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}(e,t,o):function(e,t,n){const r=de,o=me;if(f(t,o,e.spatialReference)){if(!f(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,he.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]-n[o]})(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else he.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,o)}const me=u(),de=u();function xe(e){const t=m(e.url);return n=>{var r;const o=g(n,t,t),s=o?o.replace(/^ *\.\//,""):null;return null!=(r=e.files.get(s))?r:n}}async function ye(e,t){return e instanceof Blob?ve.fromBlob(e):"string"==typeof e?new ve(e):Array.isArray(e)?async function(e,t){const n=new Map;let r=null;const o=await d(e.map((async e=>({name:e.name,source:await ye(e instanceof Blob?e:e.source,t)})))),s=[];for(const i of o)i&&(x(t)?i.source.dispose():s.push(i));y(t);for(const{name:i,source:a}of s)(v(r)||/\.(gltf|glb)/i.test(i))&&(r=a.url),n.set(i,a.url),a.files&&a.files.forEach(((e,t)=>n.set(t,e)));if(v(r))throw new w("mesh-load-external:missing-files","Missing files to load external mesh source");return new ve(r,(()=>s.forEach((({source:e})=>e.dispose()))),n)}(e,t):async function(e,t){const{default:n}=await p(import("./vendor.7103ff48.js").then((function(e){return e.q$})),t),r="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await n(e,{responseType:"array-buffer"})).data))):e.multipart;return ve.fromBlob(new Blob(r))}(e,t)}class ve{constructor(e,t=(()=>{}),n=new Map){this.url=e,this.dispose=t,this.files=n}static fromBlob(e){const t=URL.createObjectURL(e);return new ve(t,(()=>URL.revokeObjectURL(t)))}}const we=l.getLogger("esri.geometry.support.meshUtils.offset");function be(e,t,n){e.vertexAttributes&&e.vertexAttributes.position&&(c(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&we.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const n=e.origin;e.origin=b(u(),n,t)}(e.transform,t)):re(e.spatialReference,n)?function(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,o=e.vertexAttributes.normal,s=e.vertexAttributes.tangent,i=new Float64Array(r.length),a=c(o)?new Float32Array(o.length):null,l=c(s)?new Float32Array(s.length):null,f=e.extent.center,u=Re;A(n,[f.x,f.y,f.z],Fe,R(n)),F(Me,Fe),M(u,t,Me),O(r,n,i),c(o)&&j(o,r,i,n,a),c(s)&&P(s,r,i,n,l),Ae(i,u),L(i,r,n),c(o)&&z(a,r,i,n,o),c(s)&&C(l,r,i,n,s),e.vertexAttributesChanged()}(e,t):function(e,t){Ae(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t))}function Ae(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const Re=u(),Fe=S(),Me=I();const Oe={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function je(e,r,o){(function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5})(e),function(e,t){if(null==t)return;const n="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];Ce[0]=n[0],Ce[4]=n[1],Ce[8]=n[2];for(let r=0;r<e.position.length;r+=3){for(let t=0;t<3;t++)ze[t]=e.position[r+t];M(ze,ze,Ce);for(let t=0;t<3;t++)e.position[r+t]=ze[t]}if(n[0]!==n[1]||n[1]!==n[2]){Ce[0]=1/n[0],Ce[4]=1/n[1],Ce[8]=1/n[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)ze[n]=e.normal[t+n];M(ze,ze,Ce),U(ze,ze);for(let n=0;n<3;n++)e.normal[t+n]=ze[n]}}}(e,o&&o.size);const{vertexAttributes:s,transform:i}=ie(e,r,o);return{vertexAttributes:new k((l=a({},s),c={uv:e.uv},t(l,n(c)))),transform:i,components:[new $({faces:e.faces,material:o&&o.material||null})],spatialReference:r.spatialReference};var l,c}const Pe={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Le={south:0,east:1,north:2,west:3,up:4,down:5},ze=u(),Ce=I(),Se=l.getLogger("esri.geometry.support.meshUtils.rotate");function Ie(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const r=e.spatialReference;if(c(e.transform)){var o;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&Se.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=null!=(o=null==n?void 0:n.origin)?o:e.transform.getOriginPoint(r);!function(e,t,n){const r=E($e,n.x,n.y,n.z),o=T($e,r,e.origin);e.applyLocalInverse(o,Ue),e.rotation=le(e.rotation,t,ae()),e.applyLocalInverse(o,o),T(o,o,Ue),e.translation=b(u(),e.translation,o)}(e.transform,t,s)}else{var s;const r=null!=(s=null==n?void 0:n.origin)?s:e.origin;re(e.spatialReference,n)?function(e,t,n){const r=e.spatialReference,o=R(r),s=De;f(n,s,o)||f(e.origin,s,o);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(i.length),p=c(a)?new Float32Array(a.length):null,h=c(l)?new Float32Array(l.length):null;A(o,s,Te,o),F(Be,Te);const g=Ee;M(ce(Ee),ce(t),Be),g[3]=t[3],O(i,r,u),c(a)&&j(a,i,u,r,p),c(l)&&P(l,i,u,r,h),ke(u,g,3,s),L(u,i,r),c(a)&&(ke(p,g,3),z(p,i,u,r,a)),c(l)&&(ke(h,g,4),C(h,i,u,r,l)),e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=De;if(!f(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,Se.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}ke(e.vertexAttributes.position,t,3,r),ke(e.vertexAttributes.normal,t,3),ke(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,r)}}function ke(e,t,n,r=B){if(!v(e)){D(Te),G(Te,Te,fe(t),ce(t));for(let t=0;t<e.length;t+=n){for(let n=0;n<3;n++)$e[n]=e[t+n]-r[n];Z($e,$e,Te);for(let n=0;n<3;n++)e[t+n]=$e[n]+r[n]}}}const $e=u(),Ue=u(),Ee=ae(),Te=S(),Be=I(),De=u(),Ge=l.getLogger("esri.geometry.support.meshUtils.scale");function Ze(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(c(e.transform)){var o;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&Ge.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=null!=(o=null==n?void 0:n.origin)?o:e.transform.getOriginPoint(r);!function(e,t,n){const r=E(Je,n.x,n.y,n.z),o=T(Je,r,e.origin);e.applyLocalInverse(o,Xe);const s=N(u(),e.scale,t);e.scale=s,e.applyLocalInverse(o,o),T(o,o,Xe),e.translation=b(u(),e.translation,o)}(e.transform,t,s)}else{const r=re(e.spatialReference,n),o=n&&n.origin||e.origin;r?function(e,t,n){const r=e.spatialReference,o=R(r),s=Ye;f(n,s,o)||f(e.origin,s,o);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(i.length),p=c(a)?new Float32Array(a.length):null,h=c(l)?new Float32Array(l.length):null;O(i,r,u),c(a)&&j(a,i,u,r,p),c(l)&&P(l,i,u,r,h),Ne(u,t,s),L(u,i,r),c(a)&&z(p,i,u,r,a),c(l)&&C(h,i,u,r,l),e.vertexAttributesChanged()}(e,t,o):function(e,t,n){const r=Ye;if(!f(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,Ge.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Ne(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}(e,t,o)}}function Ne(e,t,n=B){if(e)for(let r=0;r<e.length;r+=3){for(let t=0;t<3;t++)Je[t]=e[r+t]-n[t];N(Je,Je,t);for(let t=0;t<3;t++)e[r+t]=Je[t]+n[t]}}const Je=u(),Xe=u(),Ye=u();var qe;const We=l.getLogger("esri.geometry.Mesh");let Ve=qe=class extends(J.LoadableMixin(X(Y))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new q,this.type="mesh"}initialize(){(v(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&c(this.external)&&c(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new W({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new h({x:0,y:0,z:0,spatialReference:t})};const n=c(this.transform)?this.transform.project(e,t):e;let r=1/0,o=1/0,s=1/0,i=-1/0,a=-1/0,l=-1/0,f=0,u=0,p=0;const g=n.length,m=1/(g/3);let d=0;for(;d<g;){const e=n[d++],t=n[d++],c=n[d++];r=Math.min(r,e),o=Math.min(o,t),s=Math.min(s,c),i=Math.max(i,e),a=Math.max(a,t),l=Math.max(l,c),f+=m*e,u+=m*t,p+=m*c}return{extent:new W({xmin:r,ymin:o,zmin:s,xmax:i,ymax:a,zmax:l,spatialReference:t}),center:new h({x:f,y:u,z:p,spatialReference:t})}}get anchor(){if(c(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new h({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return c(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&c(this.external)&&c(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push($.from(e)),this.notifyChange("components")):We.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}We.error("removeComponent()","Provided component is not part of the list of components")}else We.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,n,r){return ue(He.x,e,_e),ue(He.y,t,Ke),ue(He.z,n,Qe),le(_e,Ke,_e),le(_e,Qe,_e),Ie(this,_e,r),this}offset(e,t,n,r){return this.loaded?(et[0]=e,et[1]=t,et[2]=n,be(this,et,r),this):(We.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(Ze(this,e,t),this):(We.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(ge(this,e,t),this):(We.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return c(this.external)&&this.addResolvingPromise(async function(e,t,n){const{loadGLTFMesh:r}=await p(import("./loadGLTFMesh.e9912ccd.js"),n),o=await ye(t,n),s=r(new h({x:0,y:0,z:0,spatialReference:e.spatialReference}),o.url,{resolveFile:xe(o),useTransform:!0,signal:c(n)?n.signal:null});s.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:i,components:a}=await s;e.vertexAttributes=i,e.components=a}(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,t=this.components?new Map:null,n={components:this.components?this.components.map((n=>n.cloneWithDeduplication(e,t))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:c(this.transform)?this.transform.clone():null,external:c(this.external)?{source:this.external.source,extent:c(this.external.extent)?this.external.extent.clone():null}:null};return new qe(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:t}=await import("./gltfexport.ebd6a568.js");return t(this,e)}static createBox(e,t){if(!(e instanceof h))return We.error(".createBox()","expected location to be a Point instance"),null;const n=new qe(je(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=Pe,r=4*e.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,f=0,u=0;for(let p=0;p<e.length;p++){const r=e[p],h=l/3;for(const e of t)a[u++]=h+e;const g=r.corners;for(let e=0;e<4;e++){const t=g[e];let a=0;i[f++]=.25*n[e][0]+r.uvOrigin[0],i[f++]=r.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==r.axis[e]?(o[l++]=.5*r.axis[e],s[c++]=r.axis[e]):(o[l++]=.5*t[a++],s[c++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const n=e.components[0],r=n.faces,o=Le[t],s=6*o,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let l=0,f=0;for(let c=0;c<r.length;c++)c>=s&&c<s+6?i[l++]=r[c]:a[f++]=r[c];if(c(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),n=4*o*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new $({faces:i,material:n.material}),new $({faces:a})],e}(n,t.imageFace):n}static createSphere(e,t){return e instanceof h?new qe(je(function(e=0){const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((t-1)*n*2*3);let l=0,c=0,f=0,u=0;for(let p=0;p<=t;p++){const e=p/t*Math.PI+.5*Math.PI,r=Math.cos(e),h=Math.sin(e);ze[2]=h;const g=0===p||p===t,m=g?n-1:n;for(let d=0;d<=m;d++){const e=d/m*2*Math.PI;ze[0]=-Math.sin(e)*r,ze[1]=Math.cos(e)*r;for(let t=0;t<3;t++)o[l]=.5*ze[t],s[l]=ze[t],++l;i[c++]=(d+(g?.5:0))/n,i[c++]=p/t,0!==p&&d!==n&&(p!==t&&(a[f++]=u,a[f++]=u+1,a[f++]=u-n),1!==p&&(a[f++]=u,a[f++]=u-n,a[f++]=u-n-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(t&&t.densificationFactor||0),e,t)):(We.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof h?new qe(je(function(e=0){const t=Math.round(16*2**e),n=4*(t+1)+2*t,r=new Float64Array(3*n),o=new Float32Array(3*n),s=new Float32Array(2*n),i=new Uint32Array(4*t*3);let a=0,l=0,c=0,f=0,u=0;for(let p=0;p<=5;p++){const e=0===p||5===p,n=p<=1||p>=4,h=2===p||4===p,g=e?t-1:t;for(let m=0;m<=g;m++){const d=m/g*2*Math.PI,x=e?0:.5;ze[0]=x*Math.sin(d),ze[1]=x*-Math.cos(d),ze[2]=p<=2?.5:-.5;for(let e=0;e<3;e++)r[a++]=ze[e],o[l++]=n?2===e?p<=1?1:-1:0:2===e?0:ze[e]/x;s[c++]=(m+(e?.5:0))/t,s[c++]=p<=1?1*p/3:p<=3?1*(p-2)/3+1/3:1*(p-4)/3+2/3,h||0===p||m===t||(5!==p&&(i[f++]=u,i[f++]=u+1,i[f++]=u-t),1!==p&&(i[f++]=u,i[f++]=u-t,i[f++]=u-t-1)),u++}}return{position:r,normal:o,uv:s,faces:i}}(t&&t.densificationFactor||0),e,t)):(We.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){return e instanceof h?new qe(je(function(e){const t=Oe.facingAxisOrderSwap[e],n=Oe.position,r=Oe.normal,o=new Float64Array(n.length),s=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const e=i;for(let a=0;a<3;a++){const l=t[a],c=Math.abs(l)-1,f=l>=0?1:-1;o[i]=n[e+c]*f,s[i]=r[e+c]*f,i++}}return{position:o,normal:s,uv:new Float32Array(Oe.uv),faces:new Uint32Array(Oe.faces)}}(t&&t.facing||"up"),e,t)):(We.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(e,t){if(!(e instanceof V))return We.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=H(e);return new qe({vertexAttributes:new q({position:n.position}),components:[new $({faces:n.faces,shading:"flat",material:t&&t.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,t,n){if(!(e instanceof h))throw We.error(".createfromGLTF()","expected location to be a Point instance"),new w("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await p(import("./loadGLTFMesh.e9912ccd.js"),n);return new qe(await r(e,t,n))}static createWithExternalSource(e,t,n){var r,o,s;const i=null!=(r=null==n?void 0:n.extent)?r:null,a=null!=(o=null==n?void 0:n.transform.clone())?o:new pe;a.origin=[e.x,e.y,null!=(s=e.z)?s:0];const l=e.spatialReference;return new qe({external:{source:t,extent:i},transform:a,spatialReference:l})}static createIncomplete(e,t){var n,r;const o=null!=(n=null==t?void 0:t.transform.clone())?n:new pe;o.origin=[e.x,e.y,null!=(r=e.z)?r:0];const s=e.spatialReference,i=new qe({transform:o,spatialReference:s});return i.addResolvingPromise(Promise.reject(new w("mesh-incomplete","Mesh resources are not complete"))),i}};_([K({type:[$],json:{write:!0}})],Ve.prototype,"components",void 0),_([K({type:pe,json:{write:!0}})],Ve.prototype,"transform",void 0),_([K({constructOnly:!0})],Ve.prototype,"external",void 0),_([K({readOnly:!0})],Ve.prototype,"hasExtent",null),_([K({readOnly:!0})],Ve.prototype,"boundingInfo",null),_([K({readOnly:!0})],Ve.prototype,"anchor",null),_([K({readOnly:!0})],Ve.prototype,"origin",null),_([K({readOnly:!0,json:{read:!1}})],Ve.prototype,"extent",null),_([K({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Ve.prototype,"hasZ",void 0),_([K({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Ve.prototype,"hasM",void 0),_([K({type:q,nonNullable:!0,json:{write:!0}})],Ve.prototype,"vertexAttributes",void 0),Ve=qe=_([Q("esri.geometry.Mesh")],Ve);const He={x:ee(1,0,0),y:ee(0,1,0),z:ee(0,0,1)},_e=ae(),Ke=ae(),Qe=ae(),et=u();var tt=Ve;function nt(e,t,n){const r=n.features;n.features=[],delete n.geometryType;const o=te.fromJSON(n);o.geometryType="mesh";const s=o.spatialReference,i=v(e.outFields)||!e.outFields.length?()=>({}):(a=e.outFields.includes("*")?null:new Set(e.outFields),({attributes:e})=>{if(!e)return{};if(!a)return e;for(const t in e)a.has(t)||delete e[t];return e});var a;for(const l of r){const e=rt(l,s,t);c(e)&&o.features.push(new ne({geometry:e,attributes:i(l)}))}return o}function rt(e,t,n){const{status:r,source:o}=function(e){if(!e.assetMappings)return{status:0};const t=[],n=new Map;for(const r of e.assetMappings){const e=r.seqNo,o=r.assetName,s=r.assetURL,i=r.conversionStatus;if("FAILED"===i)return{status:0};if("COMPLETED"!==i)return{status:1};if(null==e)t.push({name:o,source:s});else{const r=n.get(o);let i;r?i=r.multipart:(i=[],t.push({name:o,source:{multipart:i}}),n.set(o,{multipart:i})),i[e]=s}}return{status:2,source:t}}(e);if(0===r)return null;const s=function({attributes:e},t,{transformFieldRoles:n}){return new h({x:e[n.originX],y:e[n.originY],z:e[n.originZ],spatialReference:t})}(e,t,n),i=W.fromJSON(e.geometry);i.spatialReference=t;const a=function({attributes:e,assetMappings:t},{transformFieldRoles:n}){var r;return new pe({translation:[e[n.translationX],e[n.translationY],e[n.translationZ]],rotation:ue([e[n.rotationX],e[n.rotationY],e[n.rotationZ]],e[n.rotationDeg]),scale:[e[n.scaleX],e[n.scaleY],e[n.scaleZ]],geographic:!(null!=(r=t.flags)&&r.includes("PROJECT_VERTICES"))})}(e,n);return 1===r?tt.createIncomplete(s,{extent:i,transform:a}):tt.createWithExternalSource(s,o,{extent:i,transform:a})}export{nt as meshFeatureSetFromJSON};
//# sourceMappingURL=meshFeatureSet.aa71dada.js.map
