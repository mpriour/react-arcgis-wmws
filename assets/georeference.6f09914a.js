import{fd as t,gu as n,gv as r,gw as e,gx as a,gy as o,gz as i,F as s,G as l,H as c,aa as g,cn as u,cs as p,gA as f,gB as h,gC as y,gD as m,gE as A,gF as d,gG as v,gH as w,gI as x,gJ as T,gK as F,gL as M,fX as R,gM as E,gN as N,gO as b,aL as z,B as j,gP as L,gQ as P,gR as _,gS as B,gT as G,M as I,gU as O,gV as S,gW as Y,gX as q,gY as H,d4 as W,f9 as X,gZ as C,g_ as D,g$ as J,h0 as K,h1 as Q,h2 as U,h3 as V,h4 as Z}from"./vendor.7103ff48.js";function $(t=et){return[t[0],t[1],t[2],t[3]]}function k(n,r,e=$()){return t(e,n),e[3]=r,e}function tt(t,r,i=$()){return n(at,t,rt(t)),n(ot,r,rt(r)),e(at,ot,at),function(t,n){return t[3]=n,t}(i,a(o(i,at)))}function nt(t){return t}function rt(t){return r(t[3])}const et=[0,0,1,0],at=i(),ot=i();var it;$();let st=it=class extends g{constructor(t){super(t),this.origin=u(),this.translation=u(),this.rotation=$(),this.scale=p(1,1,1),this.geographic=!0}get localMatrix(){const t=A();return f(t,t,this.scale),h(t,t,rt(this.rotation),this.rotation),y(t,t,this.translation),t}get localMatrixInverse(){return m(A(),this.localMatrix)}applyLocal(t,n){return d(n,t,this.localMatrix)}applyLocalInverse(t,n){return d(n,t,this.localMatrixInverse)}project(t,n){const r=new Float64Array(t.length),e=v.fromTypedArray(r),a=v.fromTypedArray(t);if(this.geographic){const t=w(x(n)),o=A();return T(n,this.origin,o,t),F(o,o,this.localMatrix),M(e,a,o),R(r,t,0,r,n,0,r.length/3),r}const{localMatrix:o,origin:i}=this;E(o,N)?b(e,a):M(e,a,o);for(let s=0;s<r.length;s+=3)r[s+0]+=i[0],r[s+1]+=i[1],r[s+2]+=i[2];return r}getOriginPoint(t){const[n,r,e]=this.origin;return new z({x:n,y:r,z:e,spatialReference:t})}equals(t){return j(t)&&this.geographic===t.geographic&&L(this.origin,t.origin)&&P(this.localMatrix,t.localMatrix)}clone(){const t={origin:_(this.origin),translation:_(this.translation),rotation:$(this.rotation),scale:_(this.scale),geographic:this.geographic};return new it(t)}};s([l({type:[Number],nonNullable:!0,json:{write:!0}})],st.prototype,"origin",void 0),s([l({type:[Number],nonNullable:!0,json:{write:!0}})],st.prototype,"translation",void 0),s([l({type:[Number],nonNullable:!0,json:{write:!0}})],st.prototype,"rotation",void 0),s([l({type:[Number],nonNullable:!0,json:{write:!0}})],st.prototype,"scale",void 0),s([l({type:Boolean,nonNullable:!0,json:{write:!0}})],st.prototype,"geographic",void 0),s([l()],st.prototype,"localMatrix",null),s([l()],st.prototype,"localMatrixInverse",null),st=it=s([c("esri.geometry.support.MeshTransform")],st);var lt=st;function ct(t,n){var r;return t.isGeographic||t.isWebMercator&&(null==(r=null==n?void 0:n.geographic)||r)}function gt(t,n,r){return ct(n.spatialReference,r)?function(t,n,r){const e=n.spatialReference,a=vt(n,r,Ft),o=new Float64Array(t.position.length),i=function(t,n,r,e){M(v.fromTypedArray(e),v.fromTypedArray(t),n);const a=new Float64Array(t.length);return B(e,a,r)}(t.position,a,e,o),s=G(Rt,a);return{position:i,normal:yt(i,o,t.normal,s,e),tangent:mt(i,o,t.tangent,s,e)}}(t,n,r):function(t,n,r){const e=new Float64Array(t.position.length),a=t.position,o=n.x,i=n.y,s=n.z||0,{horizontal:l,vertical:c}=Tt(r?r.unit:null,n.spatialReference);for(let g=0;g<a.length;g+=3)e[g+0]=a[g+0]*l+o,e[g+1]=a[g+1]*l+i,e[g+2]=a[g+2]*c+s;return{position:e,normal:t.normal,tangent:t.tangent}}(t,n,r)}function ut(t,n,r){const{position:e,normal:a,tangent:o}=t;if(I(n))return{position:e,normal:a,tangent:o};const i=n.localMatrix;return gt({position:U(e,new Float64Array(e.length),i),normal:j(a)?V(a,new Float32Array(a.length),i):null,tangent:j(o)?Z(o,new Float32Array(o.length),i):null},n.getOriginPoint(r),{geographic:n.geographic})}function pt(t,n,r){if(null!=r&&r.useTransform){var e;const{position:a,normal:o,tangent:i}=t;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new lt({origin:[n.x,n.y,null!=(e=n.z)?e:0],geographic:ct(n.spatialReference,r)})}}return{vertexAttributes:gt(t,n,r),transform:null}}function ft(t,n,r){return ct(n.spatialReference,r)?dt(t,n,r):At(t,n,r)}function ht(t,n,r,e){if(I(n))return ft(t,r,e);const a=ut(t,n,r.spatialReference);return r.equals(n.getOriginPoint(r.spatialReference))?At(a,r,e):ct(r.spatialReference,e)?dt(a,r,e):At(a,r,e)}function yt(t,n,r,e,a){if(I(r))return null;const o=new Float32Array(r.length);return O(S.fromTypedArray(o),S.fromTypedArray(r),e),Y(o,t,n,a,o),o}function mt(t,n,r,e,a){if(I(r))return null;const o=new Float32Array(r.length);O(S.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),S.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=r[i];return q(o,t,n,a,o),o}function At(t,n,r){const e=new Float64Array(t.position.length),a=t.position,o=n.x,i=n.y,s=n.z||0,{horizontal:l,vertical:c}=Tt(r?r.unit:null,n.spatialReference);for(let g=0;g<a.length;g+=3)e[g+0]=(a[g+0]-o)/l,e[g+1]=(a[g+1]-i)/l,e[g+2]=(a[g+2]-s)/c;return{position:e,normal:t.normal,tangent:t.tangent}}function dt(t,n,r){const e=n.spatialReference;vt(n,r,Ft);const a=m(Mt,Ft),o=new Float64Array(t.position.length),i=function(t,n,r,e){const a=J(t,n,e),o=v.fromTypedArray(a),i=new Float64Array(a.length),s=v.fromTypedArray(i);return M(s,o,r),i}(t.position,e,a,o),s=G(Rt,a);return{position:i,normal:wt(t.normal,t.position,o,e,s),tangent:xt(t.tangent,t.position,o,e,s)}}function vt(t,n,r){T(t.spatialReference,[t.x,t.y,t.z||0],r,H(t.spatialReference));const{horizontal:e,vertical:a}=Tt(n?n.unit:null,t.spatialReference);return f(r,r,[e,e,a]),r}function wt(t,n,r,e,a){if(I(t))return null;const o=K(t,n,r,e,new Float32Array(t.length)),i=S.fromTypedArray(o);return O(i,i,a),o}function xt(t,n,r,e,a){if(I(t))return null;const o=Q(t,n,r,e,new Float32Array(t.length)),i=S.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return O(i,i,a),o}function Tt(t,n){if(I(t))return Et;const r=n.isGeographic?1:W(n),e=n.isGeographic?1:X(n),a=C(1,t,"meters");return{horizontal:a*r,vertical:a*e}}const Ft=A(),Mt=A(),Rt=D(),Et={horizontal:1,vertical:1};export{ht as M,lt as O,ut as _,$ as a,pt as b,rt as c,k as d,ft as k,tt as q,ct as r,nt as v,gt as x};
//# sourceMappingURL=georeference.6f09914a.js.map
